////  Problem 1
//If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
//Find the sum of all the multiples of 3 or 5 below 1000.
////let sum: number = 0;
////for (let i: number = 0; i < 1000; i++) {
////    if (i % 3 == 0 || i % 5 == 0) {
////        console.log(i.toString() + "\n");
////        sum += i;
////    }
////}
////console.log("results: " + sum.toString());
//// Problem 2:
//Each new term in the Fibonacci sequence is generated by adding the previous two terms.By starting with 1 and 2, the first 10 terms will be:
//1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
//By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even- valued terms.
////let evens: number[] = [];
//fib(n: number): number {
//    if (n <= 2) {
//        return 1;
//    }
//    else {
//        return this.fib(n - 1) + this.fib(n - 2);
//    }
//}
////let result: number = 0;
////let counter: number = 1;
////let sum: number = 0;
////do {
////    result = fib(counter);
////    if (result % 2 == 0)
////        sum += result;
////    counter++;
////}
////while (result < 4000000);
////console.log(sum);
//// Problem 3
//The prime factors of 13195 are 5, 7, 13 and 29.
//What is the largest prime factor of the number 600851475143 ?
//isPrime(n: number): boolean {
//    for (let i: number = 2; i < n; i++) {
//        if (n % i == 0 && i != n) return false;
//    }
//    return true;
//}
//primeFactors(n: number): number[] {
//    let factors: number[] = [];
//    for (let i: number = 2; i <= n; i++) {
//        if (n % i == 0) {
//            factors.push(i);
//            n /= i;
//        }
//    }
//    return factors;
//}
//// Problem 4
//A palindromic number reads the same both ways.The largest palindrome made from the product of two 2- digit numbers is 9009 = 91 × 99.
//Find the largest palindrome made from the product of two 3- digit numbers.
//isPalindrome(n: number): boolean {
//    let input: string = n.toString();
//    let inverse: string = "";
//    for (let i: number = input.length - 1; i >= 0; i--) {
//        inverse += input.charAt(i);
//    }
//    return (input == inverse);
//}
////let product: number = 0;
////let toTest: number;
////for (let x: number = 100; x <= 999; x++) {
////    for (let y: number = 100; y <= 999; y++) {
////        toTest = x * y;
////        if (toTest > product && isPalindrome(toTest)) product = toTest;
////    }
////}
////console.log(product);
//// Problem 5
//2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
//What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
//isDivisibleRange(n: number, start: number, end: number): boolean {
//    let result: boolean = true;
//    for (let i = start; i <= end; i++) {
//        result = n % i == 0;
//        if (!result) break;
//    }
//    return result;
//}
////let findIt: number = 1;
////while (!isDivisibleRange(findIt, 1, 20)) {
////    findIt++;
////}
////console.log(findIt);
//// Problem 6
//The sum of the squares of the first ten natural numbers is,
//    12 + 22 + ... + 102 = 385
//The square of the sum of the first ten natural numbers is,
//    (1 + 2 + ... + 10)2 = 552 = 3025
//Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.
//Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
////var _ = require("underscore");
////const bottomNum: number = 1;
////const topNum: number = 100;
//add(a, b) {
//    return a + b;
//}
//addSquares(a, b) {
//    return a + Math.pow(b, 2);
//}
////let numbers: number[] = _.range(bottomNum, topNum + 1);
////let sumSquared: number = Math.pow(numbers.reduce(add, 0), 2);
////let sumOfSquares: number = numbers.reduce(addSquares, 0);
////console.log(sumSquared);
////console.log(sumOfSquares);
////let difference: number = sumSquared - sumOfSquares;
////console.log(difference);
//// Problem 7
//By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
//What is the 10 001st prime number?
////let bigNumString: string = '7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450';
////function isPrime(n: number): boolean {
////    for (let i: number = 2; i < n; i++) {
////        if (n % i == 0 && i != n) return false;
////    }
////    return true;
////}
////let primeCount: number = 0;
////let n: number = 1;
////do {
////    n++;
////    if (isPrime(n)) {
////        primeCount++;
////    }
////}
////while (primeCount < 10001)
////console.log(n);
//// Problem 8
//The four adjacent digits in the 1000- digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.
//73167176531330624919225119674426574742355349194934
//96983520312774506326239578318016984801869478851843
//85861560789112949495459501737958331952853208805511
//12540698747158523863050715693290963295227443043557
//66896648950445244523161731856403098711121722383113
//62229893423380308135336276614282806444486645238749
//30358907296290491560440772390713810515859307960866
//70172427121883998797908792274921901699720888093776
//65727333001053367881220235421809751254540594752243
//52584907711670556013604839586446706324415722155397
//53697817977846174064955149290862569321978468622482
//83972241375657056057490261407972968652414535100474
//82166370484403199890008895243450658541227588666881
//16427171479924442928230863465674813919123162824586
//17866458359124566529476545682848912883142607690042
//24219022671055626321111109370544217506941658960408
//07198403850962455444362981230987879927244284909188
//84580156166097919133875499200524063689912560717606
//05886116467109405077541002256983155200055935729725
//71636269561882670428252483600823257530420752963450
//Find the thirteen adjacent digits in the 1000- digit number that have the greatest product.What is the value of this product?
////const len: number = 13;
////let product: number = 0;
////for (let index: number = 0; index < bigNumString.length - len; index++) {
////    // sum each element up to len
////    let miniProduct: number = 1;
////    for (let element: number = 0; element < len; element++) {
////        miniProduct *= parseInt(bigNumString[index + element]);
////    }
////    if (miniProduct > product) product = miniProduct;
////}
////console.log(product);
//// problem 9
////let m: number = 0;
////let n: number = 2;
////do {
////    m = (500 / n) - n;
////    if ((m < n) && (Math.floor(m) === m)) {
////        console.log(n);
////        break;
////    }
////    n++;
////} while (true === true);
////let a = Math.pow(n, 2) - Math.pow(m, 2);
////let b = 2 * n * m;
////let c = Math.pow(n, 2) + Math.pow(m, 2);
////console.log(a * b * c);
//// Problem 10
//The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
//Find the sum of all the primes below two million.
//let primes: number[] = [];
//function add(a, b) {
//    return a + b;
//}
//for (let n = 2; n < 2000000; n++) {
//    if (primes.length === 0) {
//        primes.push(n);
//    } else {
//        // we only need to check up to the square root of the number for primes
//        let maxToCheck = Math.floor(Math.sqrt(n));
//        let isPrime = true;
//        // use existing primes to check. why check all when you should only check primes?
//        for (let i: number = 0; primes[i] <= maxToCheck; i++) {
//            if (n % primes[i] === 0 && primes[i] !== n) {
//                isPrime = false;
//                break;
//            }
//        }
//        if (isPrime) primes.push(n);
//    }
//}
//// sum them
//console.log(primes.reduce(add));
//// Problem 11
//In the 20×20 grid below, four numbers along a diagonal line have been marked in red.
//08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
//49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
//81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
//52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
//22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
//24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
//32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70
//67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21
//24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72
//21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95
//78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
//16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
//86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
//19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
//04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
//88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
//04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
//20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
//20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
//01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
//The product of these numbers is 26 × 63 × 78 × 14 = 1788696.
//What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?
//// get the grid in proper addressable format
//function getRight(grid: number[][], x: number, y: number): number {
//    let result: number[] = [];
//    for (let i = 0; i < sizeToGet; i++) {
//        result.push(grid[y][x + i]);
//    }
//    return result.reduce((a, b) => a * b);
//}
//function getDown(grid: number[][], x: number, y: number): number {
//    let result: number[] = [];
//    for (let i = y; i < y + sizeToGet; i++) {
//        result.push(grid[i][x]);
//    }
//    return result.reduce((a, b) => a * b);
//}
//function getDiagNW2SE(grid: number[][], x: number, y: number): number {
//    let result: number[] = [];
//    for (let i = 0; i < sizeToGet; i++) {
//        result.push(grid[y + i][x + i]);
//    }
//    return result.reduce((a, b) => a * b);
//}
//function getDiagSW2NE(grid: number[][], x: number, y: number): number {
//    let result: number[] = [];
//    for (let i = 0; i < sizeToGet; i++) {
//        result.push(grid[y - i][x + i]);
//    }
//    return result.reduce((a, b) => a * b);
//}
//let gridStrings: string[] = [];
//gridStrings.push("08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08");
//gridStrings.push("49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00");
//gridStrings.push("81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65");
//gridStrings.push("52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91");
//gridStrings.push("22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80");
//gridStrings.push("24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50");
//gridStrings.push("32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70");
//gridStrings.push("67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21");
//gridStrings.push("24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72");
//gridStrings.push("21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95");
//gridStrings.push("78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92");
//gridStrings.push("16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57");
//gridStrings.push("86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58");
//gridStrings.push("19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40");
//gridStrings.push("04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66");
//gridStrings.push("88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69");
//gridStrings.push("04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36");
//gridStrings.push("20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16");
//gridStrings.push("20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54");
//gridStrings.push("01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48");
//let grid: Array<number>[] = [];
//const sizeToGet = 4;
//for (let i: number = 0; i < gridStrings.length; i++) {
//    let numbers = gridStrings[i].split(" ");
//    let result = numbers.map((x) => parseInt(x, 10));
//    grid.push(result);
//}
//let yLastIndex = grid.length - 1;
//let final = 0;
//for (let y = 0; y < grid.length; y++) {
//    let xLastIndex = grid[y].length - 1;
//    for (let x = 0; x < grid[y].length; x++) {
//        let result: number = 0;
//        // right
//        if ((x + (sizeToGet - 1)) <= xLastIndex) {
//            result = getRight(grid, x, y);
//            if (result > final) final = result;
//        }
//        // down
//        if ((y + (sizeToGet - 1)) <= yLastIndex) {
//            result = getDown(grid, x, y);
//            if (result > final) final = result;
//        }
//        //// NWSE
//        if ((x - (sizeToGet - 1)) >= 0 && (y + (sizeToGet - 1)) <= yLastIndex) {
//            result = getDiagNW2SE(grid, x, y);
//            if (result > final) final = result;
//        }
//        //// SWNE
//        if ((x + (sizeToGet - 1)) <= xLastIndex && (y - (sizeToGet - 1)) >= 0) {
//            result = getDiagSW2NE(grid, x, y);
//            if (result > final) final = result;
//        }
//    }
//}
//console.log(final); 
//# sourceMappingURL=old.js.map